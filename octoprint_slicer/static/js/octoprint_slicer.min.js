(function (polyfill, THREE, THREETK, lodashEs, binPackingEs) {
    'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);
    var THREETK__namespace = /*#__PURE__*/_interopNamespace(THREETK);

    function OrientationOptimizer(geometry) {

        // When normal of a surface is at less than critical angle, the surface is considered overhang or bottom,
        // depending on where it sits.
        // 0.523599 is 30 degree in radians
        var CRITICAL_ANGLE = 0.523599;

        // When normal of a surface is considered perpendicular (hence the surface itself is level).
        // 0.00174533 is 0.1 degree in radians
        var PERPENDICULAR = 0.00174533;

        // When a vertex is considered "touching the bottom"
        var TOUCH_BOTTOM_TOLERANCE = 0.15;

        var self = this;

        geometry.attributes.normal.array;
        var positions = geometry.attributes.position.array;

        var surfaces = THREETK.BufferGeometryAnalyzer.sortedSurfacesByArea( geometry, 2);

        // Cost function for the optimal level of orientation. Larger is worse.
        function costFunction( bottomArea, overhangArea ) {
            var prioritizedBottom = bottomArea;
            var bottomFactor = prioritizedBottom / (prioritizedBottom + overhangArea);
            var overhangFactor = overhangArea / (prioritizedBottom + overhangArea);

            // sqrt to reflect the fact that difference matters a lot when absolute is tiny but not so much when absolute is large
            return Math.sqrt(overhangFactor) * Math.log(bottomFactor) * -1;
        }

        // The vector of the "down" direction after euler rotation is applied to object
        // It's apply the inverse of rotation matrix of the object to (0,0,-1) (imagine the new "down" line follows the inverse of objection rotation)
        function downVectorAfterRotation( euler ) {
            var matrix = new THREE__namespace.Matrix4();
            matrix.makeRotationFromEuler( euler );
            var inverse = new THREE__namespace.Matrix4();
            inverse.getInverse(matrix);
            return new THREE__namespace.Vector3(0, 0, -1).applyMatrix4(inverse);
        }

        // Assuming the original "orientation" of an object is (0,0,-1),
        // return the rotation this object has to perform to re-orient itself along given 'vector'
        // Imagine that this rotation is the inverse of rotation matrix from (0,0,-1) to 'vector' so that it "brings back"
        // the object from 'vector' to (0,0,-1)
        function eulerOfOrientationAlongVector( vector ) {
            // Use lookAt to calculate euler rotation to make model oriented along vector
            var matrix = new THREE__namespace.Matrix4();
            matrix.lookAt(new THREE__namespace.Vector3(), vector, new THREE__namespace.Vector3(0, 1, 0));
            var inverse = new THREE__namespace.Matrix4();
            inverse.getInverse(matrix);
            var obj = new THREE__namespace.Object3D();
            obj.setRotationFromMatrix(inverse);
            return obj.rotation;
        }

        function projectionToVector( vertexIndex, vector ) {
            // According to Triangular theory, project is dot product between 2 vectors
            return vector.x*positions[vertexIndex] + vector.y*positions[vertexIndex+1] + vector.z*positions[vertexIndex+2]
        }

        function largestProjectionToVector( vector ) {
            var highest = -1*Infinity;

            for ( var i = 0; i < positions.length; i+=3 ) {
                    var projection = projectionToVector( i, vector );
                    if ( projection > highest ) {
                        highest = projection;
                    }
            }
            return highest;
        }

        self.optimalOrientation = function( originalRotation, maxPivot ) {

            var originalVector = downVectorAfterRotation(originalRotation);

            // Choose the surfaces that account for 99% of the area for testing
            // De-dup orientations; make sure the angle change doesn't exceed maxPivot; and take up to 128 orientations
            var totalArea = surfaces.reduce( function(sum, surface) { return sum+surface.area }, 0);
            var areaSumSoFar = 0;
            var vectorCandidates = surfaces
                .filter( function(surface) {
                    areaSumSoFar += surface.area;
                    return areaSumSoFar/totalArea <= 0.99;
                } )
                .map( function(s) {return s.normal;} );

            var vectorsToTest = lodashEs.uniqBy(vectorCandidates, function(v) {
                    return Math.round( v.x*10000 ) + '_' + Math.round( v.y*10000 ) + '_' + Math.round( v.z*10000 );
            });

            if (maxPivot !== undefined) {
                vectorsToTest = vectorsToTest.filter( function(v) { return v.angleTo(originalVector) <= maxPivot; } );
            }
            vectorsToTest = vectorsToTest.slice(0, 127);

            var rankedOrientations = vectorsToTest.map( self.printabilityOfOrientation )
                .sort( function(a, b) { return a.printability - b.printability; } );

            return eulerOfOrientationAlongVector (
                rankedOrientations.length > 0  && rankedOrientations[0].printability != Infinity ? rankedOrientations[0].vector : originalVector );

        };

        // Compute the "printability factors" such as overhang and bottom area at a given orientation vector
        self.printabilityOfOrientation = function( orientationVector ) {

            // Largest projection represents the "bottom" of geometry along the direction of o.vector
            // Any vertex that has the same projection is considered "sitting at the bottom"
            var largestProjection = largestProjectionToVector( orientationVector );

            var bottomArea = 0;
            var overhangArea = 0;
            var bottom = [];
            var overhang = [];

            for ( var surface of surfaces ) {

                var angle = surface.normal.angleTo(orientationVector);

                if ( angle < CRITICAL_ANGLE ) {

                    if ( angle < PERPENDICULAR && (largestProjection - projectionToVector( surface.faceIndices[0], orientationVector) ) < TOUCH_BOTTOM_TOLERANCE ) {
                        bottomArea += surface.area;
                        bottom.push(surface);
                    } else {
                        overhangArea += surface.area;
                        overhang.push(surface);
                    }
                }
            }
            return { printability: costFunction( bottomArea, overhangArea),
                vector: orientationVector,
                bottomArea, overhangArea, bottom, overhang };

        };

        self.printabilityOfOrientationByRotation = function( rotation ) {
            return self.printabilityOfOrientation( downVectorAfterRotation( rotation ) );
        };
    }

    // Computes the world-axis-aligned bounding box of an object
    // (including its children), accounting for both the object's, and
    // children's, world transforms

    // Initialize with a object.  It will run on that object
    function Box3FromObject(object) {

        // Gets the points that make up the hull of the geometry, with no
        // transfomrations.
        let hullPointsFromGeometry = function(geometry) {
            // Traverses the ponts in a geometry.
            let traversePoints = function(traverseFn) {
                // Taken from Box3.expandByObject
                let v1 = new THREE__namespace.Vector3();
                if ( geometry.isGeometry ) {
                    let vertices = geometry.vertices;
                    for ( i = 0, l = vertices.length; i < l; i ++ ) {
                        v1.copy(vertices[ i ] );
                        traverseFn(v1);
                    }
                } else if ( geometry.isBufferGeometry ) {
                    let attribute = geometry.attributes.position;
                    if ( attribute !== undefined ) {
                        for ( let i = 0, l = attribute.count; i < l; i ++ ) {
                            v1.fromBufferAttribute( attribute, i );
                            traverseFn(v1);
                        }
                    }
                }
            };

            let allPoints = [];
            traversePoints(function (point) { allPoints.push(point.clone()); });
            // allPoint has all points from the geometry
            let convexHull = new THREETK.ConvexGeometry(allPoints);
            let hullMap = {};
            for (let face of convexHull.faces) {
                for (let vertexIndex of [face.a, face.b, face.c]) {
                    let hullPoint = convexHull.vertices[vertexIndex];
                    if (!hullMap[hullPoint.x]) {
                        hullMap[hullPoint.x] = {};
                    }
                    if (!hullMap[hullPoint.x][hullPoint.y]) {
                        hullMap[hullPoint.x][hullPoint.y] = {};
                    }
                    if (!hullMap[hullPoint.x][hullPoint.y][hullPoint.z]) {
                        hullMap[hullPoint.x][hullPoint.y][hullPoint.z] = {};
                    }
                }
            }
            let hullPoints = [];
            for (const x in hullMap) {
                for (const y in hullMap[x]) {
                    for (const z in hullMap[x][y]) {
                        hullPoints.push(new THREE__namespace.Vector3(x,y,z));
                    }
                }
            }
            return hullPoints;
        };

        let previousMatrixWorld = null;
        let previousBox3 = null;
    /*    object.traverse(function (node) {
            if (node.geometry && !node.userData.hullPoints) {
                node.userData.hullPoints = hullPointsFromGeometry(node.geometry);
            }
            if (!node.userData.box3FromObject) {
                node.userData.box3FromObject = Box3FromObject(node);
            }
        });*/
        return function() {
            object.updateMatrixWorld();
            let box3 = new THREE__namespace.Box3();
            let done = false;
            let previousRotation = new THREE__namespace.Matrix4();
            if (previousMatrixWorld) {
                previousRotation.extractRotation(previousMatrixWorld);
                let currentRotation = new THREE__namespace.Matrix4();
                currentRotation.extractRotation(object.matrixWorld);
                if (previousRotation.equals(currentRotation)) {
                    // Previous rotation same as current rotation so no
                    // need to recalculate the box.
                    done = true;
                }
            }
            if (!done) {
                // No previous of the rotation is different so we must
                // start over.
                if (!object.geometry) {
                    object.userData.hullPoints = [];
                } else if (!object.userData.hullPoints) {
                    object.userData.hullPoints = hullPointsFromGeometry(object.geometry);
                }
                previousMatrixWorld = object.matrixWorld.clone();
                previousRotation.extractRotation(previousMatrixWorld);
                previousBox3 = new THREE__namespace.Box3();
                for (let point of object.userData.hullPoints) {
                    previousBox3.expandByPoint(point.clone().applyMatrix4(previousMatrixWorld));
                }
            }
            // By this point, the rotation in previousMatrixWorld matches
            // the rotation in matrixWorld.  So we can just apply the
            // matrixces to the points to get the correct locations.
            if (!previousBox3.isEmpty()) {
                let previousToCurrentMatrixWorld = new THREE__namespace.Matrix4()
                    .getInverse(previousMatrixWorld)
                    .premultiply(object.matrixWorld);
                box3.expandByPoint(previousBox3.min.clone()
                                   .applyMatrix4(previousToCurrentMatrixWorld));
                box3.expandByPoint(previousBox3.max.clone()
                                   .applyMatrix4(previousToCurrentMatrixWorld));
            }
            for (let child of object.children) {
                if (!child.userData.box3FromObject) {
                    child.userData.box3FromObject = Box3FromObject(child);
                }
                let childBox3 = child.userData.box3FromObject();
                box3.expandByPoint(childBox3.min);
                box3.expandByPoint(childBox3.max);
            }
            return box3;
        };
    }

    /**
     * @author kennethjiang / https://github.com/kennethjiang
     *
     *
     * Description: A THREE view port for STL models
     *
     * Usage:
     *  var viewPort = new THREE.STLViewPort(canvas, width, height, function() {
     *     //things to do when any model in the view port changes
     *  });
     *  viewPort.init();
     *  viewPort.loadSTL(url, fucntion(model) {
     *     viewPort.selectModel(model);
     *     //things to do when model is loaded
     *  });
     *  var scene = viewPort.scene; // direct access to the scene for to add THREE.Object
     *
     */

    function STLViewPort( canvas, width, height ) {

        var self = this;

        self.canvas = canvas;
        self.canvasWidth = width;
        self.canvasHeight = height;
        self.renderingPaused = true;

        self.effectController = {
            metalness: 0.5,
            roughness: 0.5,
            modelInactiveColor: new THREE__namespace.Color("#60715b"),
            modelActiveColor: new THREE__namespace.Color("#34bf0d"),
            modelHoverColor: new THREE__namespace.Color("#84f25c"),
            ambientLightColor: new THREE__namespace.Color("#2b2b2b"),
            directionalLightColor: new THREE__namespace.Color("#ffffff"),
        };

        var eventType = { change: "change", add: "add", delete: "delete" };

        self.init = function() {

            self.camera = new THREE__namespace.PerspectiveCamera( 45, 1.0, 0.1, 5000 );

            self.camera.up.set( 0, 0, 1 );
            self.camera.position.set( -100, -200, 250 );

            self.scene = new THREE__namespace.Scene();

            // Lights
            var ambientLight = new THREE__namespace.AmbientLight( self.effectController.ambientLightColor );  // 0.2
            self.scene.add( ambientLight );
            var directionalLight = new THREE__namespace.DirectionalLight(self.effectController.directionalLightColor, 1.0);
            directionalLight.position.set( -100, -100, 500 );
            self.scene.add( directionalLight );
            var directionalLight2= new THREE__namespace.DirectionalLight(self.effectController.directionalLightColor, 1.0);
            directionalLight2.position.set( 100, 100, -500);
            self.scene.add( directionalLight2);
            var directionalLight3= new THREE__namespace.DirectionalLight(self.effectController.directionalLightColor, 0.2);
            directionalLight3.position.set( -300, 300, 500);
            self.scene.add( directionalLight3);

            self.renderer = new THREE__namespace.WebGLRenderer( { canvas: self.canvas, antialias: true } );

            self.renderer.setClearColor( 0xd8d8d8 );
            self.renderer.setSize( self.canvasWidth, self.canvasHeight );
            self.renderer.setPixelRatio( window.devicePixelRatio );

            self.renderer.gammaInput = true;
            self.renderer.gammaOutput = true;

            self.pointerInteractions = new THREETK.PointerInteractions( self.renderer.domElement, self.camera, true ); // Need to use "recursive" as the intersection will be with the mesh, not the top level objects that are nothing but holder
            self.pointerInteractions.addEventListener("click", self.selectionChanged);
            self.pointerInteractions.addEventListener("hover", self.hoverChanged);

            self.orbitControls = new THREETK.OrbitControls(self.camera, self.renderer.domElement, THREE__namespace.MOUSE.RIGHT);

            self.orbitControls.enableDamping = true;
            self.orbitControls.dampingFactor = 0.25;
            self.orbitControls.enablePan = false;
            self.orbitControls.addEventListener("change", self.render);
            self.orbitControls.addEventListener("start", self.startOrbit);
            self.orbitControls.addEventListener("end", self.endOrbit);

            // Must bind these before TransformControls because we want to attach it ourselves.
            // This will only work if events are run in the order that they are added, which is
            // true for modern browsers.
            self.renderer.domElement.addEventListener( "mousedown", self.onPointerDown, false );
            self.renderer.domElement.addEventListener( "touchstart", self.onPointerDown, false );

            self.transformControls = new THREETK.TransformControls(self.camera, self.renderer.domElement);

            self.transformControls.setRotationSnap( THREE__namespace.Math.degToRad( 15 ) );
            self.transformControls.addEventListener("change", self.render);
            self.transformControls.addEventListener("transformStart", self.startTransform);
            self.transformControls.addEventListener("transformEnd", self.endTransform);
            self.transformControls.addEventListener("objectChange", self.onChange);
            self.transformControls.space = "world";
            self.transformControls.setHandles( 'translate', null );
            self.transformControls.setMode("translate");
            self.transformControls.axis = "XY";
            self.transformControls.setHandles( 'scale', null );
            self.scene.add(self.transformControls);

            window.addEventListener( 'keydown', self.onKeydown );
            window.addEventListener( 'keyup', self.onKeyup );

            self.animate();
        };

        self.dispose = function() {

            self.orbitControls.removeEventListener("change", self.render);
            self.orbitControls.removeEventListener("start", self.startOrbit);
            self.orbitControls.removeEventListener("end", self.endOrbit);
            self.transformControls.removeEventListener("change", self.render);
            self.transformControls.removeEventListener("transformStart", self.startTransform);
            self.transformControls.removeEventListener("transformEnd", self.endTransform);
            self.transformControls.removeEventListener("objectChange", self.onChange);
            self.renderer.domElement.removeEventListener( "mousedown", self.onPointerDown, false );
            self.renderer.domElement.removeEventListener( "touchstart", self.onPointerDown, false );
            window.removeEventListener( 'keydown', self.onKeydown );
            window.removeEventListener( 'keyup', self.onKeyup );

        };

        self.pauseRendering = function() {
            self.renderingPaused = true;
        };

        self.unpauseRendering = function() {
            self.renderingPaused = false;
        };

        self.animate = function() {
            requestAnimationFrame( self.animate );

            if (!self.renderingPaused) {
                self.update();
                self.transformControls.update();
                self.orbitControls.update();
                if (self.stats) self.stats.update();

                self.render();
            }
        };

        self.update = function() {

            lodashEs.forEach( self.pointerInteractions.objects, function( model ) {
                if (model == self.selectedModel()) {
                    model.children[0].material.color.copy(self.effectController.modelActiveColor);
                } else if ( self.pointerInteractions.hoveredObject && model == self.pointerInteractions.hoveredObject.parent ) {
                    if ( self.transformControls.getMode() == "translate" ) {
                        model.children[0].material.color.copy(self.effectController.modelHoverColor);
                    }
                } else {
                    model.children[0].material.color.copy(self.effectController.modelInactiveColor);
                }
            });

        };

        self.render = function() {
            self.renderer.render( self.scene, self.camera );
        };

        self.loadSTL = function ( url, onLoad ) {
            new THREETK.STLLoader().load(url, function ( geometry ) {
                self.addModelOfGeometry(geometry);
            });
        };

        self.addModelOfGeometry = function( geometry, modelToCopyTransformFrom ) {

            var material = new THREE__namespace.MeshStandardMaterial({
                color: self.effectController.modelInactiveColor,  // We'll mark it active below.
                flatShading: true,
                side: THREE__namespace.DoubleSide,
                metalness: self.effectController.metalness,
                roughness: self.effectController.roughness,
                vertexColors: THREE__namespace.VertexColors });

            var stlModel = new THREE__namespace.Mesh( geometry, material );

            // center model's origin
            var model = new THREE__namespace.Object3D();
            model.add(stlModel);
            model.userData.box3FromObject = Box3FromObject(model);
            var center = model.userData.box3FromObject().getCenter();
            stlModel.position.copy(center.negate());
            if (modelToCopyTransformFrom) {
                model.rotation.copy(modelToCopyTransformFrom.rotation);
                model.scale.copy(modelToCopyTransformFrom.scale);
            }

            geometry.computeVertexNormals();
            model.orientationOptimizer = new OrientationOptimizer(geometry);
            self.recalculateOverhang(model);

            self.pointerInteractions.objects.push(model);
            self.pointerInteractions.update();

            self.scene.add(model);
            self.selectModel(model);

            self.dispatchEvent( { type: eventType.add, models: [ model ] } );
            return model;

        };

        // self.pointerInteractions is used to keep the source of truth for all models
        self.models = function() {
            return self.pointerInteractions.objects;
        };

        // self.transformControls is used to keep the source of truth for what model is currently selected
        self.selectedModel = function() {
            return self.transformControls.object;
        };

        self.setCursor = function(forceAuto=false) {
            if (self.transformControls.getMode() == "translate" && self.pointerInteractions.hoveredObject && !forceAuto) {
                $("#slicer-viewport").css("cursor", "move");
            } else {
                $("#slicer-viewport").css("cursor", "auto");
            }
        };

        /////////////////
        // EVENTS   /////
        // /////////////
        self.selectionChanged = function( event ) {
            $(document.activeElement).blur();
            if (event.current !== event.previous && event.current) {
                self.selectModel( event.current.parent );
            }
        };

        self.hoverChanged = function( event ) {
            self.setCursor();
        };

        self.onPointerDown = function( event ) {
            if ( self.pointerInteractions.hoveredObject && self.transformControls.getMode() == 'translate' ) {
                event.preventDefault();
                event.stopPropagation();
                self.transformControls.attach( self.pointerInteractions.hoveredObject.parent, event );
            }
        };

        self.onKeydown= function( event ) {
            switch ( event.keyCode ) {
                case 17: // Ctrl
                    self.transformControls.setRotationSnap(null);
                    break;
                case 46: // DEL key
                case 8: // backsapce key
                    if ($(document.activeElement).is('body')) {
                        self.removeSelectedModel();
                    }
                    break;
            }
        };

        self.onKeyup = function( event ) {
            switch ( event.keyCode ) {
                case 17: // Ctrl
                    self.transformControls.setRotationSnap( THREE__namespace.Math.degToRad( 15 ) );
                    break;
            }
        };

        self.onChange = function() {
            self.dispatchEvent( { type: eventType.change } );
        };

        var recentSelections = [];
        /**
         * params:
         *    m: model to make active. If m is undefined or not found, select from MRU.
         */
        self.selectModel = function(m) {
            if (self.pointerInteractions.objects.indexOf(m) > -1) {
                recentSelections.push(m);
                self.transformControls.attach(m);
            } else {
                // Requested model null or not found.  Look for a model to set active.
                while (recentSelections.length > 0) {
                    var maybe = recentSelections.pop();
                    if (self.pointerInteractions.objects.indexOf(maybe) > -1) {
                        recentSelections.push(maybe);
                        self.transformControls.attach(maybe);
                        break;
                    }
                }
                if (recentSelections.length == 0) self.transformControls.detach();
            }

            self.onChange();
        };

        self.removeModel = function( model ) {
            if ( ! model )  return;

            var index = self.pointerInteractions.objects.indexOf(model);
            if (index > -1) {
                self.pointerInteractions.objects.splice(index, 1);
            }
            self.pointerInteractions.update();

            self.scene.remove(model);
            if ( model === self.selectedModel()) {
                self.selectModel(null);
            }
        };

        self.removeSelectedModel = function() {
            var model = self.selectedModel();
            self.removeModel( model );
            self.dispatchEvent( { type: eventType.delete, models: [model] } );
        };

        self.removeAllModels = function() {
            var arrayCopy = self.pointerInteractions.objects.slice(); // Removing element while iterating the array will cause trouble in JS
            lodashEs.forEach( arrayCopy, function( model ) {
                self.removeModel( model );
            });
            self.dispatchEvent( { type: eventType.delete, models: arrayCopy} );
        };

        self.laySelectedModelFlat = function() {

            var model = self.selectedModel();
            if (! model) return;

            var newOrientation = model.orientationOptimizer.optimalOrientation( model.rotation, 0.7857); // Limit to 45 degree pivot
            model.rotation.copy( newOrientation );
            self.recalculateOverhang(model);
            self.dispatchEvent( { type: eventType.change } );

        };

        self.duplicateSelectedModel = function( copies ) {
            for (var i = 0; i < copies; i++) {
                var originalModel = self.selectedModel();
                self.addModelOfGeometry( originalModel.children[0].geometry.clone(), originalModel);
            }
        };

        self.splitSelectedModel = function() {
            if (!self.selectedModel()) {
                return;
            }

            var originalModel = self.selectedModel();
            var geometry = originalModel.children[0].geometry;
            var newGeometries = THREETK.BufferGeometryAnalyzer.isolatedGeometries(geometry);

            lodashEs.forEach(newGeometries, function(geometry) {
                self.addModelOfGeometry( geometry, originalModel );
            });

            self.removeModel( originalModel );
            self.dispatchEvent( { type: eventType.delete, models: [originalModel] } );
        };

        self.cutSelectedModel = function(height) {
            if (!self.selectedModel()) {
                return;
            }

            var originalModel = self.selectedModel();
            var geometry = originalModel.children[0].geometry;
            geometry.computeBoundingBox();
            geometry.boundingBox;
            var cutPlane = new THREE__namespace.Plane(new THREE__namespace.Vector3(0,0,1), height * -1.0);
            cutPlane.applyMatrix4(new THREE__namespace.Matrix4().getInverse(originalModel.children[0].matrixWorld));
            var mutator = new THREETK.BufferGeometryMutator().fromBufferGeometry( geometry );
            lodashEs.forEach(mutator.chop(cutPlane), function(newMutator) {            self.addModelOfGeometry( newMutator.bufferGeometry(), originalModel );
            });

            self.removeModel( originalModel );
            self.dispatchEvent( { type: eventType.delete, models: [originalModel] } );
        };

        self.startOrbit = function () {
            self.setCursor(true);
        };

        self.endOrbit = function () {
            self.setCursor();
        };

        self.startTransform = function () {
            // Disable orbit controls
            self.orbitControls.enabled = false;
        };

        self.endTransform = function () {
            // Enable orbit controls
            self.orbitControls.enabled = true;

            self.recalculateOverhang( self.selectedModel() );
        };

        self.recalculateOverhang = function(model) {
            if (!model || !model.orientationOptimizer) return;
            if ( model.userData.previousRotation && model.rotation.equals(model.userData.previousRotation ) ) {
                model.userData.previousRotation = model.rotation.clone();
                return;
            }

            var orientation = model.orientationOptimizer.printabilityOfOrientationByRotation( model.rotation );
            self.tintSurfaces(model, null, 255, 255, 255); // Clear tints off the whole model
            self.tintSurfaces(model, orientation.overhang, 128, 16, 16);
            model.userData.previousRotation = model.rotation.clone();
        };

        self.tintSurfaces = function(model, surfaces, r, g, b) {

            var geometry = model.children[0].geometry;
            var colors = geometry.attributes.color !== undefined ? geometry.attributes.color.array : [];

            if (surfaces) {

                for ( var i = 0; i < surfaces.length; i++) {
                    for ( var index of surfaces[i].faceIndices ) {
                        colors[index] = r/255;
                        colors[index+1] = g/255;
                        colors[index+2] = b/255;
                        colors[index+3] = r/255;
                        colors[index+4] = g/255;
                        colors[index+5] = b/255;
                        colors[index+6] = r/255;
                        colors[index+7] = g/255;
                        colors[index+8] = b/255;
                    }
                }

            } else {

                for ( var i = 0; i < geometry.attributes.position.array.length; i++ ) colors[i] = 1;

            }
            setGeometryColors(geometry, colors);
        };

        function setGeometryColors(geometry, colors) {
            geometry.removeAttribute( 'color' );
            geometry.addAttribute( 'color', new THREE__namespace.BufferAttribute( new Float32Array( colors ), 3 ) );
        }

    }
    STLViewPort.prototype = Object.create( THREE__namespace.EventDispatcher.prototype );
    STLViewPort.prototype.constructor = STLViewPort;

    /*
     * View model for OctoPrint-Slicer
     *
     * Author: Kenneth Jiang
     * License: AGPLv3
     */
    ko.bindingHandlers.numericValue = {
        init : function(element, valueAccessor, allBindings, data, context) {
            var interceptor = ko.computed({
                read: function() {
                    return ko.unwrap(valueAccessor());
                },
                write: function(value) {
                    if (!isNaN(value)) {
                        valueAccessor()(parseFloat(value));
                    }
                },
                disposeWhenNodeIsRemoved: element
            });

            ko.applyBindingsToNode(element, { value: interceptor }, context);
        }
    };

    function OverridesViewModel(parameters, array_keys, enum_keys, item_keys, boolean_keys) {
        var self = this;
        self.slicingViewModel = parameters[0];

        var ARRAY_KEYS = [
            "print_temperature",
            "start_gcode",
            "end_gcode",
            "before_layer_gcode",
            "filament_diameter"
        ],
            ENUM_KEYS = {
                "support" : ko.observableArray(["none", "buildplate", "everywhere"]),
                "platform_adhesion" : ko.observableArray(["none", "brim", "raft"])
            },
            ITEM_KEYS = [
                "layer_height",
                "temperature",
                "bed_temperature",
                "print_bed_temperature",
                "fill_density",
                "wall_thickness",
                "print_speed",
                "solid_layer_thickness",
                "travel_speed",
                "outer_shell_speed",
                "inner_shell_speed",
                "infill_speed",
                "bottom_layer_speed",
                "filament_flow",
                "retraction_speed",
                "retraction_amount",
                "extrusion_multiplier",
                "fan_full_height",
                "fan_speed",
                "fan_speed_max",
                "first_layer_temperature",
                "first_layer_bed_temperature",
                "brim_width",
                "skirts",
                "min_skirt_length",
                "brim_line_count",
            ],
            BOOLEAN_KEYS = [
                "support_material",
                "overhangs",
                "retraction_enable",
                "fan_enabled",
                "cooling",
                "fan_always_on",
                "spiral_vase",
            ];

        // Some options, depending on their setting, can force other
        // options.  Overrides happen last so include any trailing "%" if
        // needed.
        const FORCED_SETTINGS = new Map([
            // If spiral_vase...
            ["spiral_vase", new Map([
                // ... is set to 1 ...
                [1,
                 // Override all of the following.
                 new Map([["ensure_vertical_shell_thickness", 0],
                          ["fill_density", "0%"],
                          ["perimeters", 1],
                          ["top_solid_layers", 0],
                          ["support_material", 0],
                         ])
                ]
            ])]
        ]);

        var ALL_KEYS = BOOLEAN_KEYS.concat(ITEM_KEYS).concat(ARRAY_KEYS).concat(Object.keys(ENUM_KEYS));

        // initialize all observables
        _.forEach(ALL_KEYS, function(k) { self["profile." + k] = ko.observable(); });

        self.optionsForKey = function(key) {
            return ENUM_KEYS[key];
        };

        self.updateOverridesFromProfile = function(profile) {

            // Some options are numeric but might have a percent sign after them.
            // Remove the percent and save it to replace later.
            self.endings = {};
            var stripEndings = function(m, k) {
                if (_.isString(m[k]) && lodashEs.endsWith(m[k], "%")) {
                    self.endings[k] = "%";
                    return m[k].slice(0,-1);
                } else {
                    return m[k];
                }
            };

            // Some options are booleans but can be stored as 0/1 or false/true.
            // Convert to native true/false and keep track of the style.
            self.booleans = {};
            var convertBoolean = function(m, k) {
                var BOOLS = [
                    ["false", "true"],
                    ["False", "True"],
                    ["0", "1"],
                ];
                if (m[k] === undefined) {
                    return undefined;
                }
                for (var boolType = 0; boolType < BOOLS.length; boolType++) {
                    for (var b = 0; b < BOOLS[boolType].length; b++) {
                        if (m[k] === BOOLS[boolType][b]) {
                            self.booleans[k] = BOOLS[boolType];
                            return !!b;  // Convert 0 to false and 1 to true.
                        }
                    }
                }
                return !!m[k]; // Just take a guess if we can't figure it out.
            };


            // Hacky - Slic3r profiles escape new line to be string '\n'
            if (self.slicingViewModel.slicer() == 'slic3r'){
                _.forEach(['end_gcode', 'start_gcode', 'before_layer_gcode'], function(key) {
                    profile[key] = profile[key].replace(/\\n/g, '\n');
                });
            }

            // Some options are arrays in cura but not Slic3r.  Keep track of which.
            self.isArray = [];

            _.forEach(ITEM_KEYS, function(k) { self["profile." + k]( stripEndings(profile,k) ); });
            _.forEach(BOOLEAN_KEYS, function(k) { self["profile." + k]( convertBoolean(profile,k) ); });
            _.forEach(ENUM_KEYS, function(v, k) { self["profile." + k]( profile[k] ); });
            _.forEach(ARRAY_KEYS, function(k) {
                // Some config options are arrays in cura but not in Slic3r.
                // Detect which ones are arrays and only convert those.
                if (_.isArray(profile[k])) {
                    self.isArray.push(k);  // Remember this for later.
                    self["profile." + k](profile[k][0]);
                } else {
                    self["profile." + k](profile[k]);
                }});
        };


        self.onProfileChange = function(newValue) {
            if (newValue === undefined) {  // For some reason KO would fire event with newValue=undefined,
                return;  // in which case we should ignore it otherwise things get messed up
            }

            var slicing = self.slicingViewModel;

            if( !slicing.slicer() || !slicing.profile() ) {
                return;
            }

            self.fetchSlicingProfile( slicing.slicer(), slicing.profile() );
        };

        self.fetchSlicingProfile = function(slicer, profile) {
            if (self.profileAjax) {
                self.profileAjax.abort();
                self.profileAjax = undefined;
            }

            self.profileAjax = $.ajax({
                url: API_BASEURL + "slicing/" + slicer + "/profiles/" + profile,
                type: "GET",
                // On success
                success: function(data) {
                    self.updateOverridesFromProfile(data.data);
                }
            });
        };

        self.slicingViewModel.profile.subscribe( self.onProfileChange );
        //
        //End of Profile-handling mess


        self.toJS = function() {
            var result = ko.mapping.toJS(self, {
                ignore: ["slicingViewModel",
                    "updateOverridesFromProfile",
                    "updateOverrides",
                    "toJS",
                    "optionsForKey",
                    "stripEndings",
                    "isArray",
                    "endings"]
            });
            _.forEach(ITEM_KEYS, function(k) {
                if(self.endings.hasOwnProperty(k)) {
                    result["profile." + k] += self.endings[k];
                }});
            _.forEach(BOOLEAN_KEYS, function(k) {
                if(self.booleans.hasOwnProperty(k)) {
                    // Convert false/true to the correct string.
                    result["profile." + k] = self.booleans[k][result["profile." + k]?1:0];
                }});

            for (var key in result) {
                var baseKey = key.replace("profile.", "");
                // Convert it back to an array if it was an array originally.
                if (_.contains(ARRAY_KEYS, baseKey) && _.contains(self.isArray, baseKey)) {
                    result[key] = [result[key]];
                }
            }

            _.forEach(result, function(v, k) {
                // If the value is undefined, must not be valid for this slicer.
                if (k.startsWith("profile.") && result[k] === undefined) {
                    delete result[k];
                }
            });

            // Hacky - Slic3r profiles escape new line to be string '\n'
            if (self.slicingViewModel.slicer() == 'slic3r'){
                _.forEach(['profile.end_gcode', 'profile.start_gcode', 'profile.before_layer_gcode'], function(key) {
                    result[key] = result[key].replace(/\n/g, '\\n');
                });
            }

            // Do all the overrides.  If there are conflicting overrides,
            // it's going to behave surprisingly.
            for (let key of FORCED_SETTINGS.keys()) {
                let profile_key = "profile." + key;
                if (result.hasOwnProperty(profile_key)) {
                    // This key is in our overrides.
                    for (let value of FORCED_SETTINGS.get(key).keys()) {
                        if (result[profile_key] == value) {
                            // This value causes overriding.
                            let overrides = FORCED_SETTINGS.get(key).get(value);
                            for (let [overrideKey, overrideValue] of overrides.entries()) {
                                let profile_overrideKey = "profile." + overrideKey;
                                result[profile_overrideKey] = overrideValue;
                            }
                        }
                    }
                }
            }

            return result;
        };
    }

    // view model class, parameters for constructor, container to bind to
    OCTOPRINT_VIEWMODELS.push([
        OverridesViewModel,
        [ "slicingViewModel" ],
        [ "#basic_overrides", "#advanced_overrides" ]
    ]);

    function ModelArranger() {

        var self = this;

        var sort =  {

            w       : function (a,b) { return b.w - a.w; },
            h       : function (a,b) { return b.h - a.h; },
            a       : function (a,b) { return b.area - a.area; },
            max     : function (a,b) { return Math.max(b.w, b.h) - Math.max(a.w, a.h); },
            min     : function (a,b) { return Math.min(b.w, b.h) - Math.min(a.w, a.h); },

            height  : function (a,b) { return sort.msort(a, b, ['h', 'w']);               },
            width   : function (a,b) { return sort.msort(a, b, ['w', 'h']);               },
            area    : function (a,b) { return sort.msort(a, b, ['a', 'h', 'w']);          },
            maxside : function (a,b) { return sort.msort(a, b, ['max', 'min', 'h', 'w']); },

            msort: function(a, b, criteria) { /* sort by multiple criteria */
                var diff, n;
                for (n = 0 ; n < criteria.length ; n++) {
                    diff = sort[criteria[n]](a,b);
                    if (diff != 0)
                        return diff;
                }
                return 0;
            }

        };

        function applyPackResult(rect, packer) {
            rect.model.position.x = rect.fit.x - packer.root.w*0.5 + rect.w*0.5;
            rect.model.position.y = rect.fit.y - packer.root.h*0.5 + rect.h*0.5;
        }
        function projectedRectOnXY( model ) {
            var margin = 10.0;
            var modelBox = model.userData.box3FromObject();
            var width = modelBox.max.x - modelBox.min.x + margin;
            var height = modelBox.max.y - modelBox.min.y + margin;
            return { w: width, h: height, area: width*height, model: model };
        }
        self.arrange = function(models) {
            var rects = models.reduce( function( array, model ) {
                array.push(projectedRectOnXY(model));
                return array;
            }, []);

            // loop through all sorting criteria, and pick the best one (with smalles overall area)
            var criteria = ['w', 'h', 'a', 'max', 'min', 'height', 'width', 'area', 'maxside'];
            var allPackers = criteria.map( function( crit ) {

                rects.sort( sort[crit] );
                var packer = new binPackingEs.GrowingPacker();
                packer.fit(rects);

                return {packer: packer, rects: rects};
            });

            var packersSortedByArea = allPackers.filter( function( result ) {
                return ! result.rects.some( function(rect) { return !rect.fit; } );
            }).sort( function(a, b) {
                return b.packer.root.area - a.packer.root.area;
            });

            if (packersSortedByArea.length > 0) {
                packersSortedByArea[0].rects.forEach( function( rect ) { applyPackResult(rect, packersSortedByArea[0].packer); });
            }
        };

    }

    function CheckerboardMaterial( repeatX, repeatY, parameters, onTextureLoaded ) {

        THREE.MeshBasicMaterial.call( this );

        this.createTexture = function ( repeatX, repeatY ) {
            var texture = new THREE.TextureLoader().load( PLUGIN_BASEURL + "slicer/static/img/checkerboard.gif", function( texture ) {
                texture.minFilter = texture.magFilter = THREE.NearestFilter;
                texture.repeat.set( repeatX, repeatY );
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                if (onTextureLoaded) onTextureLoaded(texture);
            });
            return texture;
        };

        this.depthTest = true;
        this.side = THREE.DoubleSide;
        this.transparent = true;
        this.opacity = 0.15;
        this.map = this.createTexture( repeatX, repeatY );

        this.setValues( parameters );
    }
    CheckerboardMaterial.prototype = Object.create( THREE.MeshBasicMaterial.prototype );
    CheckerboardMaterial.prototype.constructor = CheckerboardMaterial;

    /*
     * View model for OctoPrint-Slicer
     *
     * Author: Kenneth Jiang
     * License: AGPLv3
     */

    function isDev() {
        return window.location.hostname == "localhost";
    }

    function SlicerViewModel(parameters) {
        mixpanel.track("App Loaded");

        var self = this;

        self.canvas = document.getElementById( 'slicer-canvas' );

        //check if webGL is present. If not disable Slicer plugin
        if ( ! THREETK__namespace.Detector.webgl ) {
            $('#tab_plugin_slicer').empty().append("<h3>Slicer Plugin is disabled because your browser doesn't support WebGL</h3>");
            return;
        }

        // assign the injected parameters, e.g.:
        self.slicingViewModel = parameters[0];
        self.overridesViewModel = parameters[1];
        self.printerStateViewModel = parameters[2];
        self.printerProfilesViewModel = parameters[3];

        self.lockScale = true;


        // Override slicingViewModel.show to surpress default slicing behavior
        self.slicingViewModel.show = function(target, file, force) {
            if (!self.slicingViewModel.enableSlicingDialog() && !force) {
                return;
            }
            mixpanel.track("Load STL");

            $('a[href="#tab_plugin_slicer"]').tab('show');

            self.setSlicingViewModelIfNeeded(target, file);
            self.addSTL(target, file);
        };

        self.resetToDefault = function() {
            self.resetSlicingViewModel();

            // hide all value inputs
            $("#slicer-viewport .values div").removeClass("show");
            updateTransformMode();
        };

        self.addSTL = function(target, file) {
            $('#tab_plugin_slicer > div.translucent-blocker').show();
            self.stlViewPort.loadSTL(BASEURL + "downloads/files/" + target + "/" + file);
        };

        self.onModelAdd = function(event) {

            var models = event.models;

            lodashEs.forEach( models, function( model ) {
                self.fixZPosition(model);
            });

            if (self.stlViewPort.models().length > 1) {
                new ModelArranger().arrange(self.stlViewPort.models());
            }
            updateValueInputs();
            updateControlState();
        };

        self.onModelDelete = function() {
            if (self.stlViewPort.models().length == 0) {
                self.resetToDefault();
            }
            updateValueInputs();
            updateControlState();
            new ModelArranger().arrange(self.stlViewPort.models());
        };

        ko.computed(function() {
            var profileName = self.slicingViewModel.printerProfile();
            if (profileName) {
                var profile = lodashEs.find(self.printerProfilesViewModel.profiles.items(), function(p) {
                    return p.id == profileName });

                var dim = profile.volume;
                self.BEDSIZE_X_MM = Math.max(dim.width, 0.1); // Safari will error if rectShape has dimensions being 0
                self.BEDSIZE_Y_MM = Math.max(dim.depth, 0.1);
                self.BEDSIZE_Z_MM = Math.max(dim.height, 0.1);
                self.BED_FORM_FACTOR = dim.formFactor;
                if (dim.origin == "lowerleft" ) {
                    self.ORIGIN_OFFSET_X_MM = self.BEDSIZE_X_MM/2.0;
                    self.ORIGIN_OFFSET_Y_MM = self.BEDSIZE_Y_MM/2.0;
                } else {
                    self.ORIGIN_OFFSET_X_MM = 0;
                    self.ORIGIN_OFFSET_Y_MM = 0;
                }
                self.drawBedFloor(self.BEDSIZE_X_MM, self.BEDSIZE_Y_MM, self.BED_FORM_FACTOR);
                self.drawWalls(self.BEDSIZE_X_MM, self.BEDSIZE_Y_MM, self.BEDSIZE_Z_MM, self.BED_FORM_FACTOR);
            }
        });

        self.slicing = ko.observable(false);

        self.BEDSIZE_X_MM = 200;
        self.BEDSIZE_Y_MM = 200;
        self.BEDSIZE_Z_MM = 200;
        self.BED_FORM_FACTOR = "rectangular";
        self.ORIGIN_OFFSET_X_MM = 0;
        self.ORIGIN_OFFSET_Y_MM = 0;

        var CANVAS_WIDTH = 588,
            CANVAS_HEIGHT = 588;


        self.init = function() {
            OctoPrint.socket.onMessage("event", self.removeTempFilesAfterSlicing);

            $('#tab_plugin_slicer > div.translucent-blocker').hide();

            self.slicingViewModel.requestData();

            self.stlViewPort = new STLViewPort(self.canvas, CANVAS_WIDTH, CANVAS_HEIGHT);
            self.stlViewPort.addEventListener( "change", self.onModelChange );
            self.stlViewPort.addEventListener( "add", self.onModelAdd );
            self.stlViewPort.addEventListener( "delete", self.onModelDelete );
            self.stlViewPort.init();

            //Walls and Floor
            self.walls = new THREE__namespace.Object3D();
            self.floor = new THREE__namespace.Object3D();
            self.origin= new THREE__namespace.Object3D();
            self.stlViewPort.scene.add(self.walls);
            self.stlViewPort.scene.add(self.floor);
            self.stlViewPort.scene.add(self.origin);

            ko.applyBindings(self.slicingViewModel, $('#slicing-settings')[0]);

            // Buttons on the canvas, and their behaviors.
            // TODO: it's not DRY. mix of prez code and logics. need to figure out a better way
            $("#slicer-viewport").empty().append('\
                  <div class="model">\
                    <button class="rotate disabled btn" title="Rotate"><img src="'
                            + PLUGIN_BASEURL
                            + 'slicer/static/img/rotate.png"></button>\
                    <button class="scale disabled btn" title="Scale"><img src="'
                            + PLUGIN_BASEURL
                            + 'slicer/static/img/scale.png"></button>\
                    <button class="remove disabled btn" title="Remove"><img src="'
                            + PLUGIN_BASEURL
                            + 'slicer/static/img/remove.png"></button>\
                    <button class="removeall disabled btn" title="Remove all"><img src="'
                            + PLUGIN_BASEURL
                            + 'slicer/static/img/removeall.png"></button>\
                    <button class="more disabled btn" title="More..."><img src="'
                            + PLUGIN_BASEURL
                            + 'slicer/static/img/more.png"></button>\
                </div>\
                <div class="values rotate">\
                    <div>\
                        <a class="close"><i class="icon-remove-sign"></i></a>\
                        <p><span class="axis x">X</span><input type="number" step="any" name="x"><span title="">°</span></p>\
                        <p><span class="axis y">Y</span><input type="number" step="any" name="y"><span title="">°</span></p>\
                        <p><span class="axis z">Z</span><input type="number" step="any" name="z"><span title="">°</span></p>\
                        <p><button id="lay-flat" class="btn"><i class="icon-glass"></i><span>&nbsp;Lay flat</span></button></p>\
                        <p><button id="rotate0" class="btn"><i class="icon-fast-backward"></i><span>&nbsp;Reset</span></button></p>\
                        <span></span>\
                    </div>\
               </div>\
                <div class="values scale">\
                    <div>\
                        <a class="close"><i class="icon-remove-sign"></i></a>\
                        <p><span class="axis x">X</span><input type="number" step="0.001" name="x" min="0.001"><span class="size x" ></span></p>\
                        <p><span class="axis y">Y</span><input type="number" step="0.001" name="y" min="0.001"><span class="size y" ></span></p>\
                        <p><span class="axis z">Z</span><input type="number" step="0.001" name="z" min="0.001"><span class="size z" ></span></p>\
                        <p class="checkbox"><label><input id="lock-scale" type="checkbox" checked>Lock</label></p>\
                        <p class="checkbox"><label><input id="mirror-x" type="checkbox">Mirror X</label><label><input id="mirror-y" type="checkbox">Mirror Y</label></p>\
                        <span></span>\
                    </div>\
               </div>\
               <div class="values more">\
                   <div>\
                       <a class="close"><i class="icon-remove-sign"></i></a>\
                       <p><button id="split" class="btn"><i class="icon-unlink"></i><span>&nbsp;Split into parts</span></button></p>\
                       <p><button id="duplicate" class="btn"><i class="icon-copy"></i><span>&nbsp;Duplicate</span></button></p>\
                       <p><button id="cut" class="btn"><i class="icon-crop"></i><span>&nbsp;Cut at height</span></button></p>\
                       <p><button id="info" class="btn"><i class="icon-info"></i><span>&nbsp;Advanced usage</span></button></p>\
                       <span></span>\
                   </div>\
               </div>');
            $("#slicer-viewport").append(self.stlViewPort.renderer.domElement);

            if ( isDev() ) {
                self.stlViewPort.stats = new Stats();
                self.stlViewPort.stats.showPanel( 1 );
                $("#slicer-viewport").append(self.stlViewPort.stats.dom);
            }

            $("#slicer-viewport button.rotate").click(function(event) {
                toggleValueInputs($("#slicer-viewport .rotate.values div"));
            });

            $("#slicer-viewport button.scale").click(function(event) {
                toggleValueInputs($("#slicer-viewport .scale.values div"));
            });

            $("#slicer-viewport button.remove").click(function(event) {
                self.stlViewPort.removeSelectedModel();
            });

            $("#slicer-viewport button.more").click(function(event) {
                toggleValueInputs($("#slicer-viewport .more.values div"));
            });

            $("#slicer-viewport button.removeall").click(function(event) {
                self.stlViewPort.removeAllModels();
                self.resetToDefault();
            });

            $("#slicer-viewport button#split").click(function(event) {
                toggleValueInputs($("#slicer-viewport .more.values div"));
                startLongRunning( self.stlViewPort.splitSelectedModel );
            });

            $("#slicer-viewport button#cut").click(function(event) {
                toggleValueInputs($("#slicer-viewport .more.values div"));
                var height = parseFloat( prompt("Cut selected object(s) at height (mm):", 1.00) );
                if (!lodashEs.isNaN(height)) {
                    startLongRunning( self.stlViewPort.cutSelectedModel.bind(self.stlViewPort, height) );
                }
            });

            $("#slicer-viewport button#duplicate").click(function(event) {
                toggleValueInputs($("#slicer-viewport .more.values div"));
                var copies = parseInt( prompt("The number of copies you want to duplicate:", 1) );
                if (!lodashEs.isNaN(copies)) {
                    startLongRunning( self.stlViewPort.duplicateSelectedModel.bind(self, copies) );
                }
            });

            $("#slicer-viewport button#info").click(function(event) {
                toggleValueInputs($("#slicer-viewport .more.values div"));
                $("#plugin-slicer-advanced-usage-info").modal("show");
            });

            $("#slicer-viewport button#lay-flat").click(function(event) {
                startLongRunning( function() {self.stlViewPort.laySelectedModelFlat(); } );
            });

            $("#slicer-viewport button#rotate0").click(function(event) {
                $("#slicer-viewport .rotate.values input").val(0);
                applyValueInputs($("#slicer-viewport .rotate.values input"));
            });

            $("#slicer-viewport .values input").on('input', function() {
                applyValueInputs($(this));
            });

            $("#slicer-viewport .values input#lock-scale").change( function(event) {
                self.lockScale = event.target.checked;
            });

            $("#slicer-viewport .values input[id^=mirror]").change( function(event) {
                applyMirrorScale(event.target);
            });

            $("#slicer-viewport .values a.close").click(function() {
                $("#slicer-viewport .values div").removeClass("show");
                updateTransformMode();
            });
        };

        self.fixZPosition = function ( model ) {
            var bedLowMinZ = 0.0;
            var boundaryBox = model.userData.box3FromObject();
            boundaryBox.min.sub(model.position);
            boundaryBox.max.sub(model.position);
            model.position.z -= model.position.z + boundaryBox.min.z - bedLowMinZ;
        };

        // callback function when models are changed by TransformControls
        self.onModelChange = function() {
            var model = self.stlViewPort.selectedModel();
            if (model) self.fixZPosition(model);

            updateValueInputs();
            updateControlState();
        };

        // Slicing
        //
        self.tempFiles = {};
        self.removeTempFilesAfterSlicing = function (event) {
            if ($.inArray(event.data.type, ["SlicingDone", "SlicingFailed"]) >= 0 &&
                event.data.payload.stl in self.tempFiles) {
                OctoPrint.files.delete(event.data.payload.stl_location,
                    event.data.payload.stl);
                delete self.tempFiles[event.data.payload.stl];
                self.slicing(false);
            }
        };

        self.sliceRequestData = function(slicingVM, groupCenter) {
            var destinationFilename = slicingVM._sanitize(slicingVM.destinationFilename());

            var destinationExtensions = slicingVM.data[slicingVM.slicer()] && slicingVM.data[slicingVM.slicer()].extensions && slicingVM.data[slicingVM.slicer()].extensions.destination
                ? slicingVM.data[slicingVM.slicer()].extensions.destination
                : ["???"];
            if (!lodashEs.some(destinationExtensions, function(extension) {
                return lodashEs.endsWith(destinationFilename.toLowerCase(), "." + extension.toLowerCase());
            })) {
                destinationFilename = destinationFilename + "." + destinationExtensions[0];
            }
            if (!groupCenter) {
                groupCenter = new THREE__namespace.Vector3(0,0,0);
            }
            var data = {
                command: "slice",
                slicer: slicingVM.slicer(),
                profile: slicingVM.profile(),
                printerProfile: slicingVM.printerProfile(),
                destination: destinationFilename,
                position: { "x": self.ORIGIN_OFFSET_X_MM + groupCenter.x,
                    "y": self.ORIGIN_OFFSET_Y_MM + groupCenter.y}
            };
            lodashEs.extend(data, self.overridesViewModel.toJS());

            if (slicingVM.afterSlicing() == "print") {
                data["print"] = true;
            } else if (slicingVM.afterSlicing() == "select") {
                data["select"] = true;
            }
            return data;
        };

        self.sendSliceRequest = function(target, filename, data) {
            $.ajax({
                url: API_BASEURL + "files/" + target + "/" + filename,
                type: "POST",
                dataType: "json",
                contentType: "application/json; charset=UTF-8",
                data: JSON.stringify(data),
                error: function(jqXHR, textStatus) {
                    new PNotify({title: "Slicing failed", text: jqXHR.responseText, type: "error", hide: false});
                    self.slicing(false);
                }
            });
        };

        self.slice = function() {
            mixpanel.track("Slice Model");

            self.slicing(true);

            var target = self.slicingViewModel.target;
            var sliceRequestData;

            var form = new FormData();
            var group = new THREE__namespace.Group();
            let groupBox3 = new THREE__namespace.Box3();
            lodashEs.forEach(self.stlViewPort.models(), function (model) {
                group.add(model.clone(true));
                groupBox3.expandByPoint(model.userData.box3FromObject().min);
                groupBox3.expandByPoint(model.userData.box3FromObject().max);
            });

            sliceRequestData = self.sliceRequestData(self.slicingViewModel, groupBox3.getCenter());

            var tempFilename = self.tempSTLFilename();
            form.append("file", self.blobFromModel(group), tempFilename);
            $.ajax({
                url: API_BASEURL + "files/local",
                type: "POST",
                data: form,
                processData: false,
                contentType: false,
                // On success
                success: function(_) {
                    self.tempFiles[tempFilename] = 1;
                    self.sendSliceRequest(target, tempFilename, sliceRequestData);
                },
                error: function(jqXHR, textStatus) {
                    new PNotify({title: "Slicing failed", text: jqXHR.responseText, type: "error", hide: false});
                    self.slicing(false);
                }
            });
        };

        self.blobFromModel = function( model ) {
            var exporter = new THREETK__namespace.STLBinaryExporter();
            return new Blob([exporter.parse(model)], {type: "text/plain"});
        };

        // END: Slicing

        // Helpers for drawing walls and floor
        //
        self.createText = function(font, text, width, depth, parentObj) {
            var textGeometry = new THREE__namespace.TextGeometry( text, {
                font: font,
                size: 10,
                height: 0.1,
                material: 0, extrudeMaterial: 1
            });
            var materialFront = new THREE__namespace.MeshBasicMaterial( { color: 0x048e06} );
            var materialSide = new THREE__namespace.MeshBasicMaterial( { color: 0x8A8A8A} );
            var materialArray = [ materialFront, materialSide ];
            var textMaterial = materialArray;

            var mesh = new THREE__namespace.Mesh( textGeometry, textMaterial );
            textGeometry.computeBoundingBox();
            var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
            var textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
            switch (text) {
                case "Front":
                    mesh.position.set(-textWidth/2, -depth/2 - textHeight - 4, 1.0);
                    break;
                case "Back":
                    mesh.position.set(textWidth/2, depth/2 + textHeight + 4, 1.0);
                    mesh.rotation.set(0, 0, Math.PI);
                    break;
                case "Left":
                    mesh.position.set(-width/2 - textHeight - 4, textWidth/2, 1.0);
                    mesh.rotation.set(0, 0, -Math.PI / 2);
                    break;
                case "Right":
                    mesh.position.set(width/2 + textHeight, -textWidth/2, 1.0);
                    mesh.rotation.set(0, 0, Math.PI / 2);
                    break;
            }
            parentObj.add(mesh);
        };

        self.drawBedFloor = function ( width, depth, formFactor) {
            var geometry;
            for(var i = self.floor.children.length - 1; i >= 0; i--) {
                var obj = self.floor.children[i];
                self.floor.remove(obj);
            }

            if (formFactor == "circular") {
                geometry = new THREE__namespace.CircleGeometry(width/2, 60);
            } else {
                geometry = new THREE__namespace.PlaneBufferGeometry(width, depth);
            }
            var material = new CheckerboardMaterial(width/20, depth/20, null, function() { self.stlViewPort.render(); });  // 20mm/checker box
            var mesh = new THREE__namespace.Mesh(geometry, material);

            mesh.receiveShadow = true;
            self.floor.add(mesh);

            //Add text to indicate front/back of print bed
            var loader = new THREE__namespace.FontLoader();
            loader.load( PLUGIN_BASEURL + "slicer/static/js/optimer_bold.typeface.json", function ( font ) {
                self.createText(font, "Front", width, depth, self.floor);
                self.createText(font, "Back", width, depth, self.floor);
                self.createText(font, "Left", width, depth, self.floor);
                self.createText(font, "Right", width, depth, self.floor);
            } );

            self.drawOrigin();
        };

        self.drawOrigin = function() {
            for(var i = self.origin.children.length - 1; i >= 0; i--) {
                var obj = self.origin.children[i];
                self.origin.remove(obj);
            }

            var material = new THREE__namespace.LineBasicMaterial({
                    color: 0x801010
            });

            const axisLength = 8;
            [[axisLength, 0, 0], [0, axisLength, 0], [0, 0, axisLength]].forEach( function(end) {
                const geometry = new THREE__namespace.Geometry();
                geometry.vertices.push(
                        new THREE__namespace.Vector3(0, 0, 0),
                        new THREE__namespace.Vector3(...end)
                );
                self.origin.add(new THREE__namespace.Line( geometry, material ));
            });

            self.origin.position.x = -self.ORIGIN_OFFSET_X_MM;
            self.origin.position.y = -self.ORIGIN_OFFSET_Y_MM;
        };

        self.drawWalls = function ( width, depth, height, formFactor ) {
            for(var i = self.walls.children.length - 1; i >= 0; i--) {
                var obj = self.walls.children[i];
                self.walls.remove(obj);
            }

            //This material will only make the inside of the cylinder walls visible while allowing the outside to be transparent.
            var wallMaterial = new THREE__namespace.MeshBasicMaterial({ color: 0x8888fc, side: THREE__namespace.BackSide, transparent: true, opacity: 0.8 });
            var invisibleMaterial = new THREE__namespace.MeshBasicMaterial({ visible: false, transparent: false });

            if (formFactor == "circular") {

                var cylGeometry = new THREE__namespace.CylinderGeometry(width/2, width/2, height, 60, 1, true);
                // Move the walls up to the floor
                cylGeometry.applyMatrix(new THREE__namespace.Matrix4().makeTranslation(0, height / 2, 0));
                var wall = new THREE__namespace.Mesh(cylGeometry, wallMaterial);
                //rotate the walls so they are upright
                wall.rotation.x = Math.PI / 2;
                self.walls.add(wall);

            } else  {

                var cubeGeometry = new THREE__namespace.BoxBufferGeometry( width, depth, height );
                var materials = [
                        wallMaterial,
                        wallMaterial,
                        wallMaterial,
                        wallMaterial,
                        invisibleMaterial,
                        invisibleMaterial,
                ];
                var cubeSidesMaterial = materials;
                var wall = new THREE__namespace.Mesh( cubeGeometry, cubeSidesMaterial );
                wall.position.z = height/2;
                self.walls.add(wall);

            }
        };

        // END: Helpers for drawing walls and floor

        self.resetSlicingViewModel = function() {
            self.slicingViewModel.target = undefined;
            self.slicingViewModel.file(undefined);
            self.slicingViewModel.destinationFilename(undefined);
        };

        self.setSlicingViewModelIfNeeded = function(target, filename) {
            if (!self.slicingViewModel.destinationFilename()) {  // A model is added to an empty bed
                self.slicingViewModel.target = target;
                self.slicingViewModel.file(filename);
                self.slicingViewModel.destinationFilename(self.computeDestinationFilename(filename));
            }
        };

        // Returns the destination filename based on which models are loaded.
        // The destination filename is without the final .gco on it because
        // that will depend on the slicer.
        self.computeDestinationFilename = function(inputFilename) {
            // TODO: For now, just use the first model's name.
            var destinationFilename = inputFilename.substr(0, inputFilename.lastIndexOf("."));
            if (destinationFilename.lastIndexOf("/") != 0) {
                destinationFilename = destinationFilename.substr(destinationFilename.lastIndexOf("/") + 1);
            }
            return destinationFilename;
        };

        self.tempSTLFilename = function() {
            var pos = self.slicingViewModel.file().lastIndexOf(".");
            return [self.slicingViewModel.file().slice(0, pos),
                ".tmp." + (+ new Date()),
                self.slicingViewModel.file().slice(pos)].join('');
        };

        // Pause WebGL rendering when slicer tab is inactive
        self.onTabChange = function (next, current) {
            if (current === "#tab_plugin_slicer") {
                self.stlViewPort.pauseRendering();
            }
        };
        self.onAfterTabChange = function (current, previous) {
            if (current === "#tab_plugin_slicer") {
                self.stlViewPort.unpauseRendering();
            }
        };

        self.init();

        //////////////////////
        // internal functions
        ///////////////////////

        function startLongRunning( func ) {
            $('#tab_plugin_slicer > div.translucent-blocker').show();
            setTimeout( function() {
                func();
                $('#tab_plugin_slicer > div.translucent-blocker').hide();
            }, 25);
        }

        function updateTransformMode() {
            if ( $("#slicer-viewport .rotate.values div").hasClass("show") ) {
                self.stlViewPort.transformControls.setMode("rotate");
                self.stlViewPort.transformControls.space = "world";
            } else if ( $("#slicer-viewport .scale.values div").hasClass("show") ) {
                self.stlViewPort.transformControls.setMode("scale");
                self.stlViewPort.transformControls.space = "local";
                self.stlViewPort.transformControls.axis = null;
            } else {
                self.stlViewPort.transformControls.setMode("translate");
                self.stlViewPort.transformControls.space = "world";
                self.stlViewPort.transformControls.axis = "XY";
            }
        }


        // Value inputs

        function updateSizeInfo() {
            var model = self.stlViewPort.selectedModel();
            if (model) {
                var size = model.userData.box3FromObject().getSize();
                $("#slicer-viewport > div.values.scale > div > p > span.size.x").text(size.x.toFixed(1) + "mm");
                $("#slicer-viewport > div.values.scale > div > p > span.size.y").text(size.y.toFixed(1) + "mm");
                $("#slicer-viewport > div.values.scale > div > p > span.size.z").text(size.z.toFixed(1) + "mm");
            }
        }

        function updateMirrorCheckboxes() {
            var model = self.stlViewPort.selectedModel();
            $("#slicer-viewport .scale.values input#mirror-x").prop('checked', model.scale.x < 0);
            $("#slicer-viewport .scale.values input#mirror-y").prop('checked',model.scale.y < 0);
        }

        function updateValueInputs() {
            var model = self.stlViewPort.selectedModel();
            if (model) {
                $("#slicer-viewport .rotate.values input[name=\"x\"]").val((model.rotation.x * 180 / Math.PI).toFixed(1)).attr("min", '');
                $("#slicer-viewport .rotate.values input[name=\"y\"]").val((model.rotation.y * 180 / Math.PI).toFixed(1)).attr("min", '');
                $("#slicer-viewport .rotate.values input[name=\"z\"]").val((model.rotation.z * 180 / Math.PI).toFixed(1)).attr("min", '');
                $("#slicer-viewport .scale.values input[name=\"x\"]").val(model.scale.x.toFixed(3)).attr("min", '');
                $("#slicer-viewport .scale.values input[name=\"y\"]").val(model.scale.y.toFixed(3)).attr("min", '');
                $("#slicer-viewport .scale.values input[name=\"z\"]").val(model.scale.z.toFixed(3)).attr("min", '');
                $("#slicer-viewport .scale.values input#lock-scale").prop('checked', self.lockScale);

                updateSizeInfo();
                updateMirrorCheckboxes();
            }
        }

        function updateControlState() {
            $('#tab_plugin_slicer > div.translucent-blocker').hide();
            if (!self.stlViewPort.selectedModel()) {
                $("#slicer-viewport button").addClass("disabled");
                $("#slicer-viewport .values div").removeClass("show");
                updateTransformMode();
            } else {
                $("#slicer-viewport button").removeClass("disabled");
            }
        }

        function toggleValueInputs(parentDiv) {
            if ( parentDiv.hasClass("show") ) {
                $("#slicer-viewport .values div").removeClass("show");
            } else if (self.stlViewPort.selectedModel()) {
                $("#slicer-viewport .values div").removeClass("show");
                parentDiv.addClass("show").children('p').addClass("show");
            }
            updateTransformMode();
        }

        function applyValueInputs(input) {
            if(input[0].type == "number" && !lodashEs.isNaN(parseFloat(input.val()))) {

                var model = self.stlViewPort.selectedModel();
                if (model === undefined) return;

                if (input.closest(".values").hasClass("scale") && self.lockScale) {
                    // Updating self in event handler will cost a lot of weirdness in user experience
                    // Therefore this very convoluted way to do "update all other scale fields except myself".
                    $("#slicer-viewport .scale.values input").each( function(i, ele) {
                        if (ele.type == "number" && ele !== input[0]) {
                            $(ele).val(input.val());
                        }
                    });
                }

                model.rotation.x =  THREE__namespace.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"x\"]").val());
                model.rotation.y =  THREE__namespace.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"y\"]").val());
                model.rotation.z =  THREE__namespace.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"z\"]").val());
                model.scale.x =  parseFloat($("#slicer-viewport .scale.values input[name=\"x\"]").val());
                model.scale.y =  parseFloat($("#slicer-viewport .scale.values input[name=\"y\"]").val());
                model.scale.z =  parseFloat($("#slicer-viewport .scale.values input[name=\"z\"]").val());

                self.fixZPosition(model);
                updateSizeInfo();
                updateMirrorCheckboxes();
                self.stlViewPort.recalculateOverhang(model);
            }
        }

        function applyMirrorScale(mirrorCheckbox) {
            var model = self.stlViewPort.selectedModel();
            if (mirrorCheckbox.id == "mirror-x") {
                model.scale.x = -1 * model.scale.x;
            }
            if (mirrorCheckbox.id == "mirror-y") {
                model.scale.y = -1 * model.scale.y;
            }
            if (mirrorCheckbox.checked) {
                self.lockScale = false;
            }

            updateValueInputs();
        }

    }


    // view model class, parameters for constructor, container to bind to
    OCTOPRINT_VIEWMODELS.push([
        SlicerViewModel,

        // e.g. loginStateViewModel, settingsViewModel, ...
        [ "slicingViewModel", "overridesViewModel", "printerStateViewModel", "printerProfilesViewModel" ],

        // e.g. #settings_plugin_slicer, #tab_plugin_slicer, ...
        [ "#slicer" ]
    ]);

}(null, THREE, THREETK, lodashEs, binPackingEs));
